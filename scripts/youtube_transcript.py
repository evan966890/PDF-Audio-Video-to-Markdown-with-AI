#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PDF-Audio-Video-to-Markdown-with-AI YouTube Transcript Module
YouTube 转录模块

Features / 功能:
- Get YouTube video subtitles (auto/manual) / 获取YouTube视频字幕（自动/手动）
- Download video and transcribe locally / 下载视频并本地转录
- Support multiple languages / 支持多种语言

Usage / 用法:
    python scripts/youtube_transcript.py https://www.youtube.com/watch?v=VIDEO_ID
    python scripts/youtube_transcript.py VIDEO_ID --lang zh
"""

import sys
import re
from pathlib import Path
from typing import Optional, List, Dict

def check_yt_dlp():
    """Check if yt-dlp is installed / 检查yt-dlp是否已安装"""
    try:
        import yt_dlp
        return True
    except ImportError:
        print("[X] yt-dlp not installed")
        print("  Tell AI: 'Please install YouTube transcript dependencies'")
        return False

def extract_video_id(url_or_id: str) -> str:
    """Extract video ID from URL or direct ID / 从URL或直接ID提取视频ID"""
    patterns = [
        r'(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/)([a-zA-Z0-9_-]{11})',
        r'^([a-zA-Z0-9_-]{11})$'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url_or_id)
        if match:
            return match.group(1)
    
    raise ValueError(f"Cannot parse video ID: {url_or_id}")

def get_available_subtitles(video_id: str) -> Dict:
    """Get available subtitles list / 获取可用字幕列表"""
    import yt_dlp
    
    url = f"https://www.youtube.com/watch?v={video_id}"
    
    ydl_opts = {
        'quiet': True,
        'no_warnings': True,
        'skip_download': True,
    }
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        
        subtitles = {}
        
        if info.get('subtitles'):
            for lang, subs in info['subtitles'].items():
                subtitles[lang] = {'type': 'manual', 'formats': [s['ext'] for s in subs]}
        
        if info.get('automatic_captions'):
            for lang, subs in info['automatic_captions'].items():
                if lang not in subtitles:
                    subtitles[lang] = {'type': 'auto', 'formats': [s['ext'] for s in subs]}
        
        return {
            'video_id': video_id,
            'title': info.get('title', ''),
            'duration': info.get('duration', 0),
            'subtitles': subtitles
        }

def download_subtitle(video_id: str, lang: str = 'zh', output_dir: str = './output') -> str:
    """Download subtitle and convert to Markdown / 下载字幕并转换为Markdown"""
    import yt_dlp
    
    url = f"https://www.youtube.com/watch?v={video_id}"
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    ydl_opts = {
        'quiet': True,
        'no_warnings': True,
        'skip_download': True,
        'writesubtitles': True,
        'writeautomaticsub': True,
        'subtitleslangs': [lang, 'en', 'zh-Hans', 'zh-Hant'],
        'subtitlesformat': 'vtt/srt/best',
        'outtmpl': str(output_path / '%(id)s'),
    }
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=True)
        title = info.get('title', video_id)
    
    # Find downloaded subtitle file / 查找下载的字幕文件
    subtitle_file = None
    for ext in ['vtt', 'srt']:
        for pattern in [f'{video_id}*.{ext}', f'{video_id}.{lang}.{ext}']:
            files = list(output_path.glob(pattern))
            if files:
                subtitle_file = files[0]
                break
        if subtitle_file:
            break
    
    if not subtitle_file:
        raise FileNotFoundError(f"Subtitle not found for {video_id}")
    
    # Convert to Markdown / 转换为Markdown
    content = subtitle_file.read_text(encoding='utf-8')
    md_content = convert_subtitle_to_markdown(content, title, video_id)
    
    # Save Markdown / 保存Markdown
    md_file = output_path / f"{video_id}.md"
    md_file.write_text(md_content, encoding='utf-8')
    
    print(f"[OK] Saved: {md_file}")
    return str(md_file)

def convert_subtitle_to_markdown(subtitle_content: str, title: str, video_id: str) -> str:
    """Convert subtitle content to Markdown format / 将字幕内容转换为Markdown格式"""
    lines = []
    
    lines.append(f"# {title}")
    lines.append("")
    lines.append(f"> YouTube: https://www.youtube.com/watch?v={video_id}")
    lines.append(f"> Generated by: PDF-Audio-Video-to-Markdown-with-AI")
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Transcript")
    lines.append("")
    
    current_text = []
    current_time = None
    
    for line in subtitle_content.split('\n'):
        line = line.strip()
        
        if line.startswith('WEBVTT') or not line or line.isdigit():
            continue
        
        time_match = re.match(r'(\d{2}:\d{2}:\d{2}[.,]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[.,]\d{3})', line)
        if time_match:
            if current_time and current_text:
                text = ' '.join(current_text)
                text = re.sub(r'<[^>]+>', '', text)
                if text.strip():
                    lines.append(f"[{current_time}] {text}")
            
            current_time = time_match.group(1)[:8]
            current_text = []
        else:
            if line and not line.startswith('NOTE'):
                current_text.append(line)
    
    if current_time and current_text:
        text = ' '.join(current_text)
        text = re.sub(r'<[^>]+>', '', text)
        if text.strip():
            lines.append(f"[{current_time}] {text}")
    
    return '\n'.join(lines)

def download_and_transcribe(video_id: str, output_dir: str = './output') -> str:
    """Download video and transcribe locally (when no subtitles available) / 下载视频并本地转录（无字幕时）"""
    import yt_dlp
    
    url = f"https://www.youtube.com/watch?v={video_id}"
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    audio_file = output_path / f"{video_id}.mp3"
    
    print(f"Downloading audio: {video_id}")
    
    ydl_opts = {
        'format': 'bestaudio/best',
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192',
        }],
        'outtmpl': str(output_path / video_id),
        'quiet': True,
    }
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=True)
        title = info.get('title', video_id)
    
    print(f"[OK] Audio downloaded")
    print(f"Transcribing...")
    
    # Use local ASR / 使用本地ASR
    from process_file import process_audio
    
    md_file = output_path / f"{video_id}.md"
    process_audio(str(audio_file), str(md_file))
    
    # Add header / 添加头部信息
    content = md_file.read_text(encoding='utf-8')
    header = f"# {title}\n\n> YouTube: {url}\n> Generated by: PDF-Audio-Video-to-Markdown-with-AI\n\n---\n\n"
    md_file.write_text(header + content, encoding='utf-8')
    
    print(f"[OK] Transcription complete: {md_file}")
    return str(md_file)

def main():
    if not check_yt_dlp():
        return 1
    
    import argparse
    
    parser = argparse.ArgumentParser(description="YouTube Transcript Tool")
    parser.add_argument("url", help="YouTube URL or video ID")
    parser.add_argument("--lang", "-l", default="zh", help="Subtitle language code (default: zh)")
    parser.add_argument("--output", "-o", default="./output", help="Output directory")
    parser.add_argument("--list", action="store_true", help="List available subtitles")
    parser.add_argument("--force-transcribe", action="store_true", 
                       help="Force download and local transcription")
    
    args = parser.parse_args()
    
    try:
        video_id = extract_video_id(args.url)
        print(f"Video ID: {video_id}")
        
        if args.list:
            info = get_available_subtitles(video_id)
            print(f"\nTitle: {info['title']}")
            print(f"Duration: {info['duration']}s")
            print(f"\nAvailable subtitles:")
            for lang, data in info['subtitles'].items():
                print(f"  - {lang} ({data['type']})")
            return 0
        
        if args.force_transcribe:
            download_and_transcribe(video_id, args.output)
        else:
            try:
                download_subtitle(video_id, args.lang, args.output)
            except FileNotFoundError:
                print("No subtitles found, trying local transcription...")
                download_and_transcribe(video_id, args.output)
        
        return 0
        
    except Exception as e:
        print(f"[X] Error: {e}")
        return 1

if __name__ == "__main__":
    exit(main())
